/*
定义dp数组，dp[i]表示前i-1个字符组成不同子序列的个数。dp数组长度设置为S.size()+1且dp[0]为0。
dp[i+1]怎么由dp[i]转换得来呢？
最简单的情况，当S[i]和前面字符都不相同时， 将S[i]加入到前面所有子序列后面都会形成新的子序列，且S[i]本身也是一个子序列，因此这种情况下dp[i+1] = dp[i] + dp[i] + 1; (注意dp[i+1]对应的是以S[i]结尾的子序列个数)。
当S[i]和前面的字符串存在重复时，比如S[i] = c 前缀字符串为abcacd；直观的可以看出，包含d的子序列不会受到影响，然后包含两个c的子序列也不会受到影响，其实可以看出受影响的只有最后一个c之前的前缀构成的子序列。因此可以得出dp[i+1] = dp[i] + dp[i] - dp[j]；其中j是最靠近S[i]且与S[i]相等的下标（注意dp[j]标识的是S[j-1]结尾的，所以这里其实是例子中abca这个字符串组成的不同子序列的个数）。
总结:
当S[i]和前面字符均不相同时：dp[i+1] = dp[i] + dp[i] + 1;
当S[i]和前面字符有相同时，找到最靠近的字符下标j：dp[i+1] = dp[i] + dp[i] - dp[j]; 两点需要注意1. dp[j]是S[j-1]结尾的个数；2. 这里的没有了+1，是因为以S[i]单独作为子序列，肯定和前面重复。此外，还定义count数组来保存每个字符最新出现的位置，避免向前遍历查找。
易错点：dp[i+1] = dp[i] + dp[i] - dp[j] 有可能为负
*/

class Solution {
public:
	int distinctSubseqII(string S)
	{
		int n = S.size();
		vector<int> count(128, -1);// 定义count数组，保存每个字符最近一次出现的位置
		vector<long> dp(n + 1, 0);
		for (int i = 1; i <= n; ++i)
		{
			if (count[S[i - 1]] < 0)
			{
				dp[i] = dp[i - 1] + dp[i - 1] + 1;
			}
			else
			{
				dp[i] = dp[i - 1] + dp[i - 1] - dp[count[S[i - 1]]];
				if (dp[i] < 0)
					dp[i] += 1000000007;
			}
			dp[i] %= 1000000007;
			count[S[i - 1]] = i - 1;// 更新count数组中S[i-1]的最新位置
		}
		return dp[n];
	}
};
